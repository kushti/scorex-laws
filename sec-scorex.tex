% !TEX root = laws.tex

\section{Scorex Architecture}
\label{sec:scorex}

Scorex is a framework for rapid implementation of a blockchain protocol client. A client is a node in a peer-to-peer network. The client has a local view of the network state. The goal of the whole peer-to-peer system~\footnote{concretely, its honest nodes. For simplicity, we omit a notion of adversarial behavior further.} is to synchronize on a part of local views which is a subject of a consensus algorithm. Scorex splits a client's local view into the following four parts: 

\begin{itemize}
\item{\em history} is an append-only log of {\em persistent modifiers}. A modifier is persistent in the sense that it has a unique identifier, and it is always possible to check if the modifier was ever appended to the history~(by presenting its identifier). There are no limitations on a modifier structure, besides the requirements to have a unique identifier and at least one parent~(referenced by its identifier). A persistent modifier may contain transactions, but this is optional. A transaction, unlike a persistent modifier, has no mandatory reference to its parents; also we consider that a transaction is not to be applied to the history and a minimal state~(described below). If a modifier is applicable to a history instance and so could be appended to it, we say that the modifier is {\em syntactically} valid. As an example, in a Bitcoin-like blockchain the history is about a chain of blocks. A block is syntactically valid if its header is well-formed according to the protocol rules, and current amount of work was spent on generating it. However, a syntactically valid block could contain invalid transaction, see a notion of semantic validity below. We note that there are alternative blockchain protocols with multiple kinds of blocks, microblocks, paired chains, and so on, that is why we have chosen abstract notions of a persistent modifier and a history, not the block and the blockchain.   

\item{\em minimal state} is a structure enough to check semantics of an arbitrary persistent modifier with a constraint that the procedure of checking has to be deterministic in nature. If a modifier is valid w.r.t minimal state, we call it a {\em semantically} valid modifier.
Thus, in addition to syntax of the blockchain, there is some stateful semantics, and minimal state takes care of it. That is, all nodes in the system do agree on some pre-historical state $S_0$, and then by applying the same sequence of persistent modifiers $m_1, \ldots, m_k$ in a deterministic way, all the nodes get the same state $S_k = apply(\ldots apply(apply(S_0, m_1), m_2), m_k)$ if all the $m_1, \ldots, m_k$ are {\em semantically} valid; otherwise a node gets an error on the first application of a semantically invalid persistent modifier. From this more abstract point of view, the goal of obtaining the state $S_k$ is to check whether a new modifier $m_{k+1}$ will be valid against it or not. Thus the minimal state has very few mandatory functions to implement, such as $apply(\cdot)$ and $rollback(\cdot)$ (the latter is needed for forks processing).

\item{\em vault} contains user-specific information. For a user running a node, the goal to run it is usually to get valuable user-specific information from processing the history. For that, the vault component is used which has the only functions to update itself by scanning a persistent modifier or a transaction and also to rollback to some previous state. A wallet is the perfect example of a vault implementation. 

\item{\em memory pool} is storing transactions to be packed into persistent modifiers.
\end{itemize}

The history and the minimal state are parts of local views to be synchronized across the network by using a distributed and decentralized consensus algorithm. Nodes run a consensus protocol to form a proper history, and the history should result in a valid minimal state when persistent modifiers from the history are applied to a publicly known prehistorical state.

The whole node view quadruple is to be updated atomically by applying either a persistent node view modifier or an unconfirmed transaction. Scorex provides guarantees of atomicity and consistency for the application while a developer of a concrete system needs to provide implementations for the abstract parts of the quadruple as well as a family of persistent modifiers.

A central component which holds the quadruple {\em <history, minimal state, vault, memory pool>} and processes its updates atomically is called a {\em node view holder}. The holder is processing all the received commands to update the quadruple in sequence, even if they are received from multiple threads. If the holder gets a transaction, it updates the vault and the memory pool with it. Otherwise, if the holder gets a persistent modifier, it first updates the history by appending the modifier to it. In a simplest case, if appending is successful~(so if the modifier is syntactically valid), the modifier is then applied to the minimal state. However, sometimes a fork happens, so the state is needed to be rolled back first, and then a new sequence of persistent modifiers is to be applied to it. 

As an example, we consider the cryptocurrency Twinscoin~\cite{cryptoeprint:2017:232}, which is based on a hybrid proof-of-work and proof-of-stake consensus protocol. Scorex has a full-fledged Twinscoin implementation as an example of its usage. There are two kinds of persistent modifiers in Twinscoin: a proof-of-work block and a proof-of-stake block. Thus the blockchain is hybrid: after a Proof-of-Work block it could be only a Proof-of-Stake block, and on top of it there could be only a Proof-of-Work block again. Thus a TwinsCoin-powered blockchain is actually two chains braided together. Only Proof-of-Stake block could contain transactions. Such complicated design makes Scorex a good framework to implement the TwinsCoin proposal. Unfortunately, TwinsCoin authors made only some particular tests. We got working tests for the Twinscoin client just by writing generators for transactions and persistent modifiers.

It could be the case that in a decentralized network two generators are issuing a block at the same time, or in the presence of a temporary network split different nodes are working on different suffixes starting with the same chain, or an adversary may generate blocks in private and then present them to the network. In short, a fork could happen. This is a normal situation once majority of block generators are honest~(see~\cite{Garay2015} for formal analysis of the Bitcoin proof-of-work protocol).    

Processing forks in a client could be a complicated issue, making testing of this functionality important. We proceed by describing the way in which forking is implemented in Scorex. When a persistent modifier is appended to a history instance, the history returns~(if the modifier is syntactically valid) {\em progress info} structure which contains a sequence of persistent modifiers to apply as well as a possible identifier of a modifier to perform rollback~(for the minimal state, vault, memory pool) to before the application of the sequence. By such a realization of the interfaces, Scorex allows history to be non-linear~(for example, it could be a block tree), but other components of the node view quadruple have sequential logic. For efficiency reasons, the minimal state is usually limited in maximal depth for a rollback, so the rollback could fail~(this situation is probably unresolvable in a satisfactory way without a human intervention). 
